#~ The sequence of triangle numbers is generated by adding the natural
#~ numbers. So the 7th triangle number would
#~ be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
#~
#~ 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
#~
#~ Let us list the factors of the first seven triangle numbers:
#~
     #~ 1: 1
     #~ 3: 1,3
     #~ 6: 1,2,3,6
    #~ 10: 1,2,5,10
    #~ 15: 1,3,5,15
    #~ 21: 1,3,7,21
    #~ 28: 1,2,4,7,14,28
#~
#~ We can see that 28 is the first triangle number to have over five
#~ divisors.
#~
#~ What is the value of the first triangle number to have over five hundred
#~ divisors?

from euler_tools.prime import is_prime

def triangle_values(max_n=None):
    current = 1
    n = 1
    while (max_n == None) or (n < max_n):
        yield current
        n += 1
        current += n


def primes(max=None):
    n = 1
    while (max == None) or (n < max):
        if is_prime(n):
            yield n
        n += 1

def anzahl_teiler(n):
    retval = 0
    for m in xrange(1, n + 1):
        if n % m == 0:
            retval += 1
    return retval

def anzahl_teiler4(n):
    if n == 1:
        return 1

    retval = 0
    max_m = n
    for m in xrange(1, n + 1):
        if m >= max_m:
            break

        if n % m == 0:
            retval += 2
            max_m = n / m
            if max_m == m:
                retval -= 1 # 2*2, 3*3, ...

    return retval

class SieveOfEratosthenes():
    def __init__(self):
        self.known_primes = [2, 3, 5, 7]
        self.next_check = 8

    def range(self, max=None):
        for n in self.known_primes:
            if max != None and n >= max:
                return

            yield n

        while (max == None) or (self.next_check < max):
            is_prime_flag = True
            for p in self.known_primes:
                if self.next_check % p == 0:
                    is_prime_flag = False
                    break

            p = self.next_check
            self.next_check += 1

            if is_prime_flag:
                #~ print "New Prime: %s" % n
                self.known_primes.append(p)
                yield p

def anzahl_teiler3(n, s):
    retval = 2 # 1, n
    for m in s.range(n / 2):
        if n % m == 0:
            retval += 2

    return retval

def test_anzahl_teiler():
    s = SieveOfEratosthenes()
    for n in range(10000):
        if anzahl_teiler(n) != anzahl_teiler4(n):
            print "anzahl_teiler(%s) = %s, anzahl_teiler4(%s) = %s" %\
                (n, anzahl_teiler(n), n, anzahl_teiler4(n))
def solve():
    s = SieveOfEratosthenes()
    #210276

    max_divisors = 0
    for n in triangle_values():
        #~ print "%s Teiler: %s" % (n, anzahl_teiler3(n, s))
        divisors = anzahl_teiler4(n)
        if divisors > max_divisors:
            print "%s Teiler: %s" % (n, divisors)
            max_divisors = divisors

    #~ print anzahl_teiler(210276)
